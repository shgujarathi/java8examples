List<String> result = lines.stream().filter(line -> !"mkyong".equals(line)).collect(Collectors.toList());

Map<String, Long> counting = items.stream().collect(Collectors.groupingBy(Item::getName, Collectors.counting()));

Map<String, Integer> sum = items.stream().collect(Collectors.groupingBy(Item::getName, Collectors.summingInt(Item::getQty)));

--------------------------------------
Abstraction    -190 Page
Encapsulation
Polymorphism
Inheritance
--------------------------------------
Overloading - Method Resolution taken care by compiler
Overriding - method Resolution taken care by jvm(Runtime)
--------------------------------------
Method hiding - Parent class have Static method and inherting child class also have same static method (Same method sig and same return type)
this is called method hiding.
--------------------------------------
There are several differences between HashMap and Hashtable in Java:

Hashtable is synchronized, whereas HashMap is not. This makes HashMap better for non-threaded applications, 
as unsynchronized Objects typically perform better than synchronized ones.
Hashtable does not allow null keys or values.  HashMap allows one null key and any number of null values.
One of HashMap's subclasses is LinkedHashMap, 
so in the event that you'd want predictable iteration order (which is insertion order by default), 
you could easily swap out the HashMap for a LinkedHashMap. This wouldn't be as easy if you were using Hashtable.
Since synchronization is not an issue for you, I'd recommend HashMap. 
If synchronization becomes an issue, you may also look at ConcurrentHashMap.
--------------------------------------
Arrays can hold only primitives where as collections can hold both primitive and objects.
Arrays are best according to Performance and worst according to memory where as collections are reverse.
--------------------------------------
concurrent modification

This exception may be thrown by methods that have detected concurrent modification of an object when such modification is not permissible.
For example, it is not generally permissible for one thread to modify a Collection while another thread is iterating over it. 
In general, the results of the iteration are undefined under these circumstances. 
Some Iterator implementations (including those of all the general purpose collection implementations provided by the JRE) 
may choose to throw this exception if this behavior is detected. 
Iterators that do this are known as fail-fast iterators, as they fail quickly and cleanly,
rather that risking arbitrary, non-deterministic behavior at an undetermined time in the future.

Note that this exception does not always indicate that an object has been concurrently modified by a different thread.
If a single thread issues a sequence of method invocations that violates the contract of an object,
the object may throw this exception. For example,if a thread modifies a collection directly while it is iterating over the 
collection with a fail-fast iterator, the iterator will throw this exception.
--------------------------------------
In every collection class toString method is overridden to print desired format while used in sysout
ArrayList is more versatile than vector because we can get synchronized list or read-only list from arraylist easily using Collections utility class.
-----------------------------------------
Java 1.5 Concurrent package (java.util.concurrent) contains thread-safe collection classes that allow collections 
to be modified while iterating.

By design Iterator implementation in java.util packages are fail-fast and throws ConcurrentModificationException.

But Iterator implementation in java.util.concurrent packages are fail-safe and we can modify the collection while iterating. 

Some of these classes are CopyOnWriteArrayList, ConcurrentHashMap, CopyOnWriteArraySet.
------------------------------------------------------------------------------------------
JAVA 8 Features

Lambda Expression: This allows you to pass an anonymous function as object.
Stream API: Allows you to take advantage of multiple cores of modern CPU and lets you write concise code.
Date and Time API: There is a solid and easy to use date and time library in JDK.
Extension Methods: You can include static and default method into your interface.
Repeated Annotation: This lets you apply the same annotation multiple times on a type.

-------------------------------------------------------------------------------------------
throw keyword	/ throws keyword  

1)throw is used to explicitly throw an exception.	throws is used to declare an exception.
2)checked exceptions can not be propagated with throw only.	checked exception can be propagated with throws.
3)throw is followed by an instance.	throws is followed by class.
4)throw is used within the method.	throws is used with the method signature.
5)You cannot throw multiple exception	You can declare multiple exception e.g. public void method()throws IOException,SQLException.
----------------------------

Singleton class means that any given time only one instance of the class is present, in one JVM

-----------------------------------------------
Since salary ( In Employee Object )is a transient variable, it’s value was not saved to file and hence not retrieved in the new object. 
Similarly static variable values are also not serialized since they belongs to class and not object.

---------------------------------------------------------------------
Hibernate session comes with different methods to load data from database. get and load are most used methods, at first look they seems similar but there are some differences between them.

get() loads the data as soon as it’s called whereas load() returns a proxy object and loads data only when it’s actually required, so load() is better because it support lazy loading.
Since load() throws exception when data is not found, we should use it only when we know data exists.
We should use get() when we want to make sure data exists in the database.

-----------------------------------------------------------------

Zipkin as spring boot app will not work for spring boot(2.X versions)
------------------------------------------------------------------------
For Spring Config server for communicating with Remote GIT need to disable HTTP SSL 

Using  RUN git config --global http.sslVerify false 
--------------------------------------------------------------------------------
Docker related Commands

Docker Network
docker network create networkName - to create docker network
docker network ls - network list 
docker network connect networkname containername -> to connect container to docker 
docker network inspect networkname - > to check what all containers are connect
docker container ps -a
docker images
docker network ls 	
docker rm spring-config-server spring-config-client spring-slueth-app
docker network rm spring-config-server_configconnect
docker run -p 8001:8001 --name spring-config-client --link spring-config-server spring-config-client
docker pull splunk/splunk
docker run -d -e "SPLUNK_START_ARGS=--accept-license" -e "SPLUNK_USER=root" -p "8000:8000" splunk/splunk

----------------------------
Stateless 

Statelessness means that every HTTP request happens in complete isolation. 
When the client makes an HTTP request, it includes all information necessary for the server to fulfill that request.
The server never relies on information from previous requests. 
If that information was important, the client would have sent it again in this request. 
Statelessness also brings new features. It’s easier to distribute a stateless application across load-balanced servers. 
A stateless application is also easy to cache.

There are actually two kinds of state. Application State that lives on the client and Resource State that lives on the server.

A web service only needs to care about your application state when you’re actually making a request
The rest of the time, it doesn’t even know you exist. 

This means that whenever a client makes a request, it must include all the application states the server will need to process it.

Resource state is the same for every client, and its proper place is on the server.
When you upload a picture to a server, you create a new resource: the new picture has its own URI and can be the target of future requests. 
You can fetch, modify, and delete this resource through HTTP.

Hope this helps differentiate what statelessness and various states mean.

----------------------------------
A Functional Interface is an interface, which contains one and only one abstract method. Functional Interface is also know as SAM Interface because it contains only one abstract method.
SAM Interface stands for Single Abstract Method Interface. Java SE 8 API has defined many Functional Interfaces.

Yes, it is possible to define our own Functional Interfaces. We use Java SE 8’s @FunctionalInterface annotation to mark an interface as Functional Interface.
We need to follow these rules to define a Functional Interface:

Define an interface with one and only one abstract method.
We cannot define more than one abstract method.
Use @FunctionalInterface annotation in interface definition.
We can define any number of other methods like Default methods, Static methods.
If we override java.lang.Object class’s method as an abstract method, which does not count as an abstract method.
-------------------------------------------------------------------------------
https://stackoverflow.com/questions/23862994/what-is-the-difference-between-hibernate-and-spring-data-jpa

Hibernate is a JPA implementation, while Spring Data JPA is a JPA Data Access Abstraction. Spring Data offers a solution to GenericDao custom implementations. It can also generate JPA queries on your behalf through method name conventions.

With Spring Data, you may use Hibernate, Eclipse Link or any other JPA provider. A very interesting benefit is that you can control transaction boundaries declaratively using the @Transactional annotation.

Spring JDBC is much more lightweight, and it's intended for native querying, and if you only intend to use JDBC alone, then you are better off using Spring JDBC to deal with the JDBC verbosity.

So, Hibernate,and Spring Data are complementary rather than competitors.

There are 3 different things we are using here :

JPA : Java persistence api which provide specification for persisting, reading, managing data from your java object to relations in database.
Hibernate: There are various provider which implement jpa. Hibernate is one of them. So we have other provider as well. But if using jpa with spring it allows you to switch to different providers in future.
Spring Data JPA : This is another layer on top of jpa which spring provide to make your life easy.
So lets understand how spring data jpa and spring + hibernate works-

Spring Data JPA:
Let's say you are using spring + hibernate for your application. 
Now you need to have dao interface and implementation where you will be writing crud operation using SessionFactory of hibernate. Let say you are writing dao class for Employee class, tomorrow in your application you might need to write similiar crud operation for any other entity. So there is lot of boilerplate code we can see here.

Now Spring data jpa allow us to define dao interfaces by extending its repositories(crudrepository, jparepository)
so it provide you dao implementation at runtime. You don't need to write dao implementation anymore.Thats how spring data jpa makes your life easy.
-------------------------------------------------------------------------------
https://dzone.com/articles/testing-databases-junit-and

https://dzone.com/articles/integrate-h2-database-in-your-spring-boot-applicat 

Joincolumn and mapped by 
https://stackoverflow.com/questions/11938253/whats-the-difference-between-joincolumn-and-mappedby-when-using-a-jpa-onetoma

@jsonignoreproperties
https://fasterxml.github.io/jackson-annotations/javadoc/2.6/com/fasterxml/jackson/annotation/JsonIgnoreProperties.html            

@JsonIgnoreProperties({"hibernateLazyInitializer","handler"}) -> Jackson unable to serialize some data which is created by hibernate lazy issue so for ignoring that use this 
http://www.greggbolinger.com/ignoring-hibernate-garbage-via-jsonignoreproperties/

spring.jpa.properties.hibernate.enable_lazy_load_no_trans
https://stackoverflow.com/questions/25362831/solve-hibernate-lazy-init-issue-with-hibernate-enable-lazy-load-no-trans



---------------------------------------------------

Difference between MocitoJunitRunner and SpringRunner
https://stackoverflow.com/questions/49635396/runwithspringrunner-class-vs-runwithmockitojunitrunner-class

The SpringRunner provides support for loading a Spring ApplicationContext and having beans @Autowired into your test instance. 
It actually does a whole lot more than that (covered in the Spring Reference Manual), but that's the basic idea.

Whereas, the MockitoJUnitRunner provides support for creating mocks and spies with Mockito.

However, with JUnit 4, you can only use one Runner at a time.

Thus, if you want to use support from Spring and Mockito simultaneously, you can only pick one of those runners.

But you're in luck since both Spring and Mockito provide rules in addition to runners.

For example, you can use the Spring runner with the Mockito rule as follows.

@RunWith(SpringRunner.class)
@SpringBootTest
public class MyTests {

    @Rule
    public MockitoRule rule = MockitoJUnit.rule();

    @Mock
    MyService myService;

    // ...
}
Though, typically, if you're using Spring Boot and need to mock a bean from the Spring ApplicationContext 
you would then use Spring Boot's @MockBean support instead of simply @Mock.

-------------------------------------------------------------------------------------------
Difference between doReturn/when
https://stackoverflow.com/questions/20353846/mockito-difference-between-doreturn-and-when

The two syntaxes for stubbing are roughly equivalent. However, you can always use doReturn/when for stubbing; but there are cases where you can't use when/thenReturn. Stubbing void methods is one such. Others include use with Mockito spies, and stubbing the same method more than once.

One thing that when/thenReturn gives you, that doReturn/when doesn't, is type-checking of the value that you're returning, at compile time. However, I believe this is of almost no value - if you've got the type wrong, you'll find out as soon as you run your test.

I strongly recommend only using doReturn/when. There is no point in learning two syntaxes when one will do.

You may wish to refer to my answer at Forming Mockito "grammars" - a more detailed answer to a very closely related question.
--
Both approaches behave differently if you use a spied object (annotated with @Spy) instead of a mock (annotated with @Mock):

when(...) thenReturn(...) makes a real method call just before the specified value will be returned. So if the called method throws an Exception you have to deal with it / mock it etc. Of course you still get your result (what you define in thenReturn(...))

doReturn(...) when(...) does not call the method at all.

Example:

public class MyClass {
     protected String methodToBeTested() {
           return anotherMethodInClass();
     }

     protected String anotherMethodInClass() {
          throw new NullPointerException();
     }
}
Test:

@Spy
private MyClass myClass;

// ...

// would work fine
doReturn("test").when(myClass).anotherMethodInClass();

// would throw a NullPointerException
when(myClass.anotherMethodInClass()).thenReturn("test");
------------------------------------
Spring helps in the creation of loosely coupled applications because of Dependency Injection.
In Spring, objects define their associations (dependencies) and do not worry about how they will get those dependencies. 
It is the responsibility of Spring to provide the required dependencies for creating objects.
For example: Suppose we have an object Employee and it has a dependency on object Address.
 We would define a bean corresponding to Employee that will define its dependency on object Address.

When Spring tries to create an Employee object, it will see that Employee has a dependency on Address,
 so it will first create the Address object (dependent object) and then inject it into the Employee object.

Inversion of Control (IOC) and Dependency Injection (DI) are used interchangeably. IOC is achieved through DI.
 DI is the process of providing the dependencies and IOC is the end result of DI. 
 (Note: DI is not the only way to achieve IOC. There are other ways as well.)

By DI, the responsibility of creating objects is shifted from our application code to the Spring container; 
this phenomenon is called IOC.

Dependency Injection can be done by setter injection or constructor injection.

